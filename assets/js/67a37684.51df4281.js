"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([["32"],{6912:function(e,n,s){s.r(n),s.d(n,{default:()=>p,frontMatter:()=>a,metadata:()=>t,assets:()=>l,toc:()=>c,contentTitle:()=>r});var t=JSON.parse('{"id":"cli/extensions/extension_example","title":"Extension Example","description":"In this chapter, we\'ll go over a simple real-world example of what a Phylum CLI","source":"@site/../docs/cli/extensions/extension_example.md","sourceDirName":"cli/extensions","slug":"/cli/extensions/extension_example","permalink":"/cli/extensions/extension_example","draft":false,"unlisted":false,"editUrl":"https://github.com/phylum-dev/cli/edit/main/docs/extensions/extension_example.md","tags":[],"version":"current","lastUpdatedBy":"Kyle Willmon","lastUpdatedAt":1716331118000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Extension API","permalink":"/cli/extensions/extension_api"},"next":{"title":"Extension Sandboxing","permalink":"/cli/extensions/extension_sandboxing"}}'),i=s("5893"),o=s("65");let a={},r="Extension Example",l={},c=[];function d(e){let n={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"extension-example",children:"Extension Example"})}),"\n",(0,i.jsx)(n.p,{children:"In this chapter, we'll go over a simple real-world example of what a Phylum CLI\nextension might look like."}),"\n",(0,i.jsx)(n.p,{children:"Our goal is writing an extension which can print out all dependencies with more\nthan one version present in our dependency file."}),"\n",(0,i.jsx)(n.p,{children:"The full example looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { mapValues } from "https://deno.land/std@0.150.0/collections/map_values.ts";\nimport { distinct } from "https://deno.land/std@0.150.0/collections/distinct.ts";\nimport { groupBy } from "https://deno.land/std@0.150.0/collections/group_by.ts";\n\n// Ensure dependency file argument is present.\nif (Deno.args.length != 1) {\n    console.error("Usage: phylum duplicates <DEPENDENCY_FILE>");\n    Deno.exit(1);\n}\n\n// Parse dependency file using Phylum\'s API.\nconst depfile = await Phylum.parseDependencyFile(Deno.args[0]);\n\n// Group all versions for the same dependency together.\nconst groupedDeps = groupBy(depfile.packages, dep => dep.name);\n\n// Reduce each dependency to a list of its versions.\nconst reducedDeps = mapValues(groupedDeps, deps => deps.map(dep => dep.version));\n\nfor (const [dep, versions] of Object.entries(reducedDeps)) {\n    // Deduplicate identical versions.\n    const distinctVersions = distinct(versions);\n\n    // Print all dependencies with more than one version.\n    if (distinctVersions.length > 1) {\n        console.log(`${dep}:`, distinctVersions);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Now there's a lot to unpack here, so we'll go through things one by one:"}),"\n",(0,i.jsx)(n.p,{children:"Before we can start writing our extension code, we need to create our new\nextension:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"phylum extension new duplicates\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can then start writing the extension by replacing ",(0,i.jsx)(n.code,{children:"./duplicates/main.ts"})," with\nour example code:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'import { mapValues } from "https://deno.land/std@0.150.0/collections/map_values.ts";\nimport { distinct } from "https://deno.land/std@0.150.0/collections/distinct.ts";\nimport { groupBy } from "https://deno.land/std@0.150.0/collections/group_by.ts";\n'})}),"\n",(0,i.jsxs)(n.p,{children:["These are the Deno API imports. We use version ",(0,i.jsx)(n.code,{children:"0.150.0"})," of ",(0,i.jsx)(n.a,{href:"https://deno.land/std",children:"Deno's STD"}),"\nhere and import the required functions by loading them as remote ES modules.\nWe'll go into more detail on what we need these for later."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// Ensure dependency file argument is present.\nif (Deno.args.length != 1) {\n    console.error("Usage: phylum duplicates <DEPENDENCY_FILE>");\n    Deno.exit(1);\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Deno.args"})," variable contains an array with all CLI arguments passed after\nour extension name, so for ",(0,i.jsx)(n.code,{children:"phylum my-extension one two"})," that would be ",(0,i.jsx)(n.code,{children:'["one", "two"]'}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Here we make sure that we get exactly one parameter and print a useful help\nmessage to the terminal if no parameter was provided."}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Deno.exit"})," function will terminate the extension and return the provided\nerror code."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Parse dependency file using Phylum's API.\nconst depfile = await Phylum.parseDependencyFile(Deno.args[0]);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Phylum's API is exposed in the global ",(0,i.jsx)(n.code,{children:"Phylum"})," object. Here we are using the\n",(0,i.jsx)(n.code,{children:"parseDependencyFile"})," method which reads the lockfile or manifest path passed as\nan argument and returns an object containing all dependencies and the package\necosystem. Since this function is asynchronous, we need to ",(0,i.jsx)(n.code,{children:"await"})," it."]}),"\n",(0,i.jsx)(n.p,{children:"The returned object will look something like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'{\n  packages: [\n    { type: "npm", name: "accepts", version: "1.3.8" },\n    { type: "npm", name: "array-flatten", version: "1.1.1" },\n    { type: "npm", name: "accepts", version: "1.0.0" }\n  ],\n  package_type: "npm",\n  path: "package-lock.json"\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Group all versions for the same dependency together.\nconst groupedDeps = groupBy(depfile.packages, dep => dep.name);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since our package list contains multiple instances of the same dependency, we\nneed to group each instance together to find duplicate versions. Deno's\nconvenient ",(0,i.jsx)(n.code,{children:"groupBy"})," function does this for us automatically and we just need to\ntell it which field to group by using ",(0,i.jsx)(n.code,{children:"dep => dep.name"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"This will transform our package list into the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'{\n  accepts: [\n      { name: "accepts", version: "1.3.8" },\n      { name: "accepts", version: "1.0.0" }\n  ],\n  "array-flatten": [ { name: "array-flatten", version: "1.1.1" } ]\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// Reduce each dependency to a list of its versions.\nconst reducedDeps = mapValues(groupedDeps, deps => deps.map(dep => dep.version));\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since our dependency structure now contains useless information like ",(0,i.jsx)(n.code,{children:"name"})," and\n",(0,i.jsx)(n.code,{children:"type"}),", we map each of these grouped values to contain only the version numbers\nfor each dependency."]}),"\n",(0,i.jsx)(n.p,{children:"This results in a simple array with all dependencies and their versions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'{\n  accepts: ["1.3.8", "1.0.0"],\n  "array-flatten": ["1.1.1"]\n}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"for (const [dep, versions] of Object.entries(reducedDeps)) {\n"})}),"\n",(0,i.jsx)(n.p,{children:"Since we now have an object containing all dependencies and the required\nversions, we can iterate over all fields in this object to check the number of\nversions it has."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"    // Deduplicate identical versions.\n    const distinctVersions = distinct(versions);\n"})}),"\n",(0,i.jsx)(n.p,{children:"But before we can check the versions themselves, we need to make sure all the\nversions are actually unique. Some dependency files might specify the same\nversion multiple times, so we need to ensure we filter duplicate versions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"    // Print all dependencies with more than one version.\n    if (distinctVersions.length > 1) {\n        console.log(`${dep}: `, distinctVersions);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"With all versions deduplicated, we can finally print out each dependency with\nmore than one version in our dependency file."}),"\n",(0,i.jsx)(n.p,{children:"For our example, the output looks like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'accepts: [ "1.3.8", "1.0.0" ]\n'})}),"\n",(0,i.jsxs)(n.p,{children:["And that's all the code we need to check for duplicates. Now we can use the\n",(0,i.jsx)(n.code,{children:"phylum extension run"})," subcommand to test the extension without installing it:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"phylum extension run ./duplicates ./package-lock.json\n"})}),"\n",(0,i.jsx)(n.p,{children:"This should then print the following error:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-text",children:'Extension error: Uncaught (in promise) Error: Requires read access to "./package-lock.json"\n    at async Function.parseDependencyFile (deno:phylum:201:16)\n    at async file:///tmp/duplicates/main.ts:12:14\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Phylum's extensions are executed in a sandbox with restricted access to\noperating system APIs. Since we want to read the lockfile from\n",(0,i.jsx)(n.code,{children:"./package-lock.json"})," with the ",(0,i.jsx)(n.code,{children:"parseDependencyFile"})," method, we need to request\nread access to this file ahead of time. All available permissions are documented\nin the ",(0,i.jsx)(n.a,{href:"/cli/extensions/extension_manifest#permissions",children:"extension manifest documentation"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["While it would be possible to request read access to just ",(0,i.jsx)(n.code,{children:"./package-lock.json"}),",\nthis would only work for ",(0,i.jsx)(n.code,{children:"package-lock.json"})," files defeating the purpose of\npassing the dependency file as a parameter. Instead, we request read access to\nall files in the working directory:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[permissions]\nread = ["./"]\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively if you wanted to allow read access to any file, so dependency\nfiles outside of the working directory are supported, you could use ",(0,i.jsx)(n.code,{children:"read = true"})," instead."]}),"\n",(0,i.jsxs)(n.p,{children:["Now ",(0,i.jsx)(n.code,{children:"phylum extension run"})," should prompt for these permissions and complete\nwithout any errors if they have been granted. Then we can install and run our\nextension:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"phylum extension install ./duplicates\nphylum duplicates ./package-lock.json\n"})})]})}function p(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},65:function(e,n,s){s.d(n,{Z:function(){return r},a:function(){return a}});var t=s(7294);let i={},o=t.createContext(i);function a(e){let n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);